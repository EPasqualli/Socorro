/* Remove membros do arquivo VINAc */
int remover_membros(const char *arquivo, char **membros, int num_membros) {
    if (!arquivo || !membros || num_membros <= 0) return 1;
    
    diretorio_vinac_t *dir = carregar_diretorio(arquivo);
    if (!dir) {
        printf("Erro ao carregar diretório de %s\n", arquivo);
        return 1;
    }
    
    // Verificar se todos os membros existem
    for (int i = 0; i < num_membros; i++) {
        if (!encontrar_entrada(dir, membros[i])) {
            printf("Membro %s não encontrado no arquivo %s\n", membros[i], arquivo);
            liberar_diretorio(dir);
            return 1;
        }
    }
    
    // Criar um arquivo temporário para reorganizar os dados
    char arquivo_temp[1024];
    snprintf(arquivo_temp, sizeof(arquivo_temp), "%s.tmp", arquivo);
    
    FILE *arquivo_vinac = fopen(arquivo, "rb");
    FILE *temp = fopen(arquivo_temp, "wb");
    
    if (!arquivo_vinac || !temp) {
        printf("Erro ao abrir arquivos para remoção\n");
        if (arquivo_vinac) fclose(arquivo_vinac);
        if (temp) fclose(temp);
        liberar_diretorio(dir);
        return 1;
    }
    
    // Copiar o cabeçalho para o arquivo temporário
    cabecalho_vinac_t novo_cabecalho = dir->cabecalho;
    novo_cabecalho.num_membros -= num_membros;  // Reduzir o número de membros
    
    if (fwrite(&novo_cabecalho, sizeof(cabecalho_vinac_t), 1, temp) != 1) {
        printf("Erro ao escrever cabeçalho no arquivo temporário\n");
        fclose(arquivo_vinac);
        fclose(temp);
        remove(arquivo_temp);
        liberar_diretorio(dir);
        return 1;
    }
    
    // Criar diretório para o novo arquivo
    diretorio_vinac_t *novo_dir = criar_diretorio();
    if (!novo_dir) {
        printf("Erro ao criar novo diretório\n");
        fclose(arquivo_vinac);
        fclose(temp);
        remove(arquivo_temp);
        liberar_diretorio(dir);
        return 1;
    }
    
    novo_dir->cabecalho = novo_cabecalho;
    
    // Copiar membros que não serão removidos
    for (uint32_t i = 0; i < dir->cabecalho.num_membros; i++) {
        // Verificar se o membro atual deve ser removido
        int remover = 0;
        for (int j = 0; j < num_membros; j++) {
            if (strcmp(dir->entradas[i].nome, membros[j]) == 0) {
                remover = 1;
                break;
            }
        }
        
        if (remover) {
            printf("Removendo membro %s\n", dir->entradas[i].nome);
            continue;  // Pular este membro
        }
        
        // Copiar o membro para o novo arquivo
        entrada_vinac_t nova_entrada = dir->entradas[i];
        nova_entrada.offset = ftell(temp);  // Atualizar
}